<!DOCTYPE subprocess>
<html lang="es">
<head>
<meta charset="UTF-8" />
<title>Neon Dash 2.6 - Optimizado para Rendimiento</title>
<style>
/* ----------------------------------- */
/* PALETA DE COLORES NEÃ“N VIBRANTE */
/* ----------------------------------- */
Â  body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
Â  #progressBarContainer {
Â  Â  position: fixed; top: 0; left: 0; width: 100%; height: 20px;
Â  Â  background: #111; box-shadow: 0 0 8px #f06; /* Rosa NeÃ³n */
Â  Â  z-index: 10;
Â  }
Â  #progressBar { height: 100%; width: 0; background: linear-gradient(90deg, #60f, #0ff, #f06); } /* Degradado NeÃ³n */
Â  /* OptimizaciÃ³n: Sin margen superior, alineado al borde. */
Â  canvas { display: block; margin: 0 auto; background: #000; } 
Â  #uiScreens { 
    position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
    background: #000; 
    z-index: 5; 
}
Â  .screen { 
    background: #000; 
    color: #0ff; 
    display: flex; 
    flex-direction: column;
Â  Â  justify-content: center; 
    align-items: center; 
    font-size: 32px; 
    text-shadow: 0 0 15px #0ff; 
  }
Â  .screen { display: none; }
Â  #startScreen { display: flex; }
Â  button { margin: 12px; padding: 18px 35px; font-size: 22px; cursor: pointer;
Â  Â  background: #f06; /* Rosa NeÃ³n */
Â  Â  border: none; color: #fff; border-radius: 12px;
Â  Â  box-shadow: 0 0 25px #f06;
Â  Â  transition: transform 0.1s, box-shadow 0.3s;
Â  }
Â  button:hover {
Â  Â  transform: scale(1.05);
Â  Â  box-shadow: 0 0 35px #fff, 0 0 45px #f06;
Â  }
Â  #levelSelect { flex-wrap: wrap; padding: 20px; }
Â  #levelSelect button {
Â  Â  background: #60f; /* Violeta NeÃ³n */
Â  Â  box-shadow: 0 0 20px #60f;
Â  }
</style>
</head>
<body>

<div id="progressBarContainer" style="display:none;">
Â  <div id="progressBar"></div>
</div>

<div id="uiScreens">
Â  <div id="startScreen" class="screen">
Â  Â  <div>âœ¨ **NEON DASH 2.6** âœ¨</div>
Â  Â  <button id="playBtn">Jugar</button>
Â  </div>

Â  <div id="levelSelect" class="screen">
Â  Â  <div>Selecciona Nivel (6 en total)</div>
Â  Â  <button class="levelBtn" data-level="1">Nivel 1 ğŸ§Š</button>
Â  Â  <button class="levelBtn" data-level="2">Nivel 2 âš¡</button>
Â  Â  <button class="levelBtn" data-level="3">Nivel 3 ğŸš€</button>
Â  Â  <button class="levelBtn" data-level="4">Nivel 4 ğŸ›¸ (UFO)</button>
Â  Â  <button class="levelBtn" data-level="5">Nivel 5 ğŸŒŒ</button>
Â  Â  <button class="levelBtn" data-level="6">Nivel 6 ğŸ”¥</button>
Â  Â  <button id="backBtn" style="background: #222; box-shadow: none;">â† Volver</button>
Â  </div>

Â  <div id="gameOver" class="screen">
Â  Â  <div id="gameOverText"></div>
Â  Â  <button id="restartBtn">Reintentar</button>
Â  </div>
</div>

<canvas id="gameCanvas" width="800" height="200" style="display:none;"></canvas>

<script>
Â  const screens = {
Â  Â  start: document.getElementById('startScreen'),
Â  Â  levels: document.getElementById('levelSelect'),
Â  Â  over: document.getElementById('gameOver')
Â  };
Â  const uiScreensContainer = document.getElementById('uiScreens');
Â  const canvas = document.getElementById('gameCanvas');
Â  const ctx = canvas.getContext('2d');
Â  const progressBarContainer = document.getElementById('progressBarContainer');
Â  const progressBar = document.getElementById('progressBar');

Â  let gameState = 'start';
Â  let currentLevel = 1;
Â  let score = 0;
Â  let distanceTraveled = 0;
Â  const levelLength = 15000;

Â  // Constantes de fÃ­sica
Â  const CUBE_GRAVITY = 0.7;
Â  const CUBE_JUMP = -13;
Â  const UFO_GRAVITY = 0.5; 
Â  const UFO_BOUNCE = -6; 

Â  let player = {Â 
Â  Â  x: 50,Â  y: 150,Â  size: 25,Â  dy: 0,Â 
Â  Â  mode: 'cube', 
Â  Â  gravity: CUBE_GRAVITY,Â  jumpPower: CUBE_JUMP,Â 
Â  Â  grounded: true, rotation: 0
Â  };
Â Â 
Â  let obstacles = [];
Â  let portals = [];
Â  let blocks = [];

Â  const levelData = {
Â  Â  1: { speed: 2.2, minGap: 320, spikeHeight: 28, color: '#0ff' },
Â  Â  2: { speed: 2.6, minGap: 290, spikeHeight: 30, color: '#0f0' },
Â  Â  3: { speed: 3.0, minGap: 270, spikeHeight: 32, color: '#f06' },
Â  Â  4: { speed: 3.4, minGap: 250, spikeHeight: 34, color: '#ff0', hasUfo: true },
Â  Â  5: { speed: 3.8, minGap: 230, spikeHeight: 36, color: '#60f', hasUfo: true, hasPlane: true },
Â  Â  6: { speed: 4.2, minGap: 210, spikeHeight: 38, color: '#fff', hasUfo: true, hasPlane: true }
Â  };

Â  function showScreen(screen) {
Â  Â  Object.values(screens).forEach(s => s.style.display = 'none');
Â  Â  
Â  Â  if (screen === 'playing') {
Â  Â  Â  uiScreensContainer.style.display = 'none'; 
Â  Â  Â  canvas.style.display = 'block';
Â  Â  Â  progressBarContainer.style.display = 'block';
Â  Â  } else {
Â  Â  Â  uiScreensContainer.style.display = 'block'; 
Â  Â  Â  screens[screen].style.display = 'flex';
Â  Â  Â  canvas.style.display = 'none';
Â  Â  Â  progressBarContainer.style.display = 'none';
Â  Â  }
Â  }

Â  function initLevel(level) {
Â  Â  currentLevel = level;
Â  Â  obstacles = [];
Â  Â  portals = [];
Â  Â  blocks = [];
Â  Â  distanceTraveled = 0;
Â  Â  score = 0;
Â  Â  const data = levelData[level];
Â  Â Â 
Â  Â  player = { 
Â  Â  Â  x: 50, y: 150, size: 25, dy: 0, 
Â  Â  Â  mode: 'cube', gravity: CUBE_GRAVITY, jumpPower: CUBE_JUMP, 
Â  Â  Â  grounded: true, rotation: 0 
Â  Â  };

Â  Â  let posX = 450;
Â  Â  for (let i = 0; i < 60; i++) {
Â  Â  Â  posX += data.minGap + Math.random() * 80;
Â  Â  Â  obstacles.push({ x: posX, y: 152, width: 18, height: data.spikeHeight, visualWidth: 26, type: 'spike', speed: data.speed, color: data.color });
Â  Â  }
Â  Â Â 
Â  Â  let blockPos = 800;
Â  Â  for (let i = 0; i < 20; i++) {
Â  Â  Â  blockPos += 300 + Math.random() * 150;
Â  Â  Â  blocks.push({ x: blockPos, y: Math.random() > 0.5 ? 140 : 160, width: 60 + Math.random() * 40, height: 12, type: 'block', speed: data.speed });
Â  Â  }
Â  Â Â 
Â  Â  if (data.hasUfo && level === 4) portals.push({ x: 2800, y: 90, width: 40, height: 40, type: 'ufo', speed: data.speed });
Â  Â  if (data.hasUfo && level > 4) portals.push({ x: 4000, y: 90, width: 40, height: 40, type: 'ufo', speed: data.speed });
Â  }

Â  function drawAnimatedCube() {
Â  Â  ctx.save();
Â  Â  ctx.translate(player.x + player.size/2, player.y + player.size/2);

Â  Â  if (player.mode === 'cube') {
Â  Â  Â  if (!player.grounded) {
Â  Â  Â  Â  player.rotation += Math.PI / 18;
Â  Â  Â  } else {
Â  Â  Â  Â  player.rotation = Math.round(player.rotation / (Math.PI / 2)) * (Math.PI / 2);
Â  Â  Â  }
Â  Â  } else if (player.mode === 'ufo') {
Â  Â  Â  player.rotation += Math.PI / 60;
Â  Â  }

Â  Â  ctx.rotate(player.rotation);
Â  Â Â 
Â  Â  const color = levelData[currentLevel].color;
Â  Â  // Usa menos shadow blur para optimizar
Â  Â  ctx.shadowColor = color;
Â  Â  ctx.shadowBlur = 15; 
Â  Â  ctx.fillStyle = color;
Â  Â Â 
Â  Â  if (player.mode === 'cube') {
Â  Â  Â  ctx.fillRect(-player.size/2, -player.size/2, player.size, player.size);
Â  Â  Â  ctx.shadowBlur = 0;
Â  Â  Â  ctx.strokeStyle = '#000';
Â  Â  Â  ctx.lineWidth = 3;
Â  Â  Â  ctx.strokeRect(-player.size/2 + 5, -player.size/2 + 5, player.size - 10, player.size - 10);
Â  Â  } else if (player.mode === 'ufo') {
Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.ellipse(0, 0, 15, 8, 0, 0, Math.PI * 2);
Â  Â  Â  ctx.fill();
Â  Â  Â  ctx.fillRect(-10, -10, 20, 20);
Â  Â  }
Â  Â Â 
Â  Â  ctx.restore();
Â  Â  ctx.shadowBlur = 0; // DESACTIVAR sombreado global
Â  }

Â  function drawRealisticSpikes() {
Â  Â  // CONFIGURAR sombreado UNA SOLA VEZ antes del bucle
Â  Â  const spikeColor = levelData[currentLevel].color;
Â  Â  ctx.shadowColor = spikeColor;
Â  Â  ctx.shadowBlur = 10; 
Â  Â  ctx.fillStyle = spikeColor;
Â  Â Â 
Â  Â  obstacles.forEach(obs => {
Â  Â  Â  // CÃLCULO DE COORDENADAS: Evita ctx.save/restore dentro del bucle
Â  Â  Â  const baseX = obs.x + obs.visualWidth/2;
Â  Â  Â  const baseY = obs.y + obs.height - 2;
Â  Â  Â Â 
Â  Â  Â  // Dibujo del triÃ¡ngulo (punta de neÃ³n)
Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.moveTo(baseX, baseY - obs.height + 4);
Â  Â  Â  ctx.lineTo(baseX - obs.visualWidth/2 + 2, baseY);
Â  Â  Â  ctx.lineTo(baseX + obs.visualWidth/2 - 2, baseY);
Â  Â  Â  ctx.fill();
Â  Â  Â Â 
Â  Â  Â  // Dibujo del cuerpo oscuro (interior del pico)
Â  Â  Â  ctx.shadowBlur = 0; // Desactivamos el blur temporalmente para el relleno oscuro
Â  Â  Â  ctx.fillStyle = '#111';
Â  Â  Â  ctx.fillRect(obs.x + 3, baseY - obs.height + 4, obs.visualWidth - 6, obs.height - 4);
Â  Â  Â  ctx.shadowBlur = 10; // Reactivamos el blur para el siguiente pico
Â  Â  });
Â  Â  // IMPORTANTE: Desactivar sombreado global
Â  Â  ctx.shadowBlur = 0;
Â  }

Â  function drawBlocks() {
Â  Â  // CONFIGURAR sombreado UNA SOLA VEZ
Â  Â  ctx.shadowColor = '#0f0';
Â  Â  ctx.shadowBlur = 8; // Menor blur para optimizar
Â  Â  ctx.fillStyle = '#333';
Â  Â  ctx.strokeStyle = '#0f0';
Â  Â  ctx.lineWidth = 3;
Â  Â Â 
Â  Â  blocks.forEach(block => {
Â  Â  Â  ctx.fillRect(block.x, block.y, block.width, block.height);
Â  Â  Â  // El stroke se verÃ¡ con el mismo blur
Â  Â  Â  ctx.strokeRect(block.x, block.y, block.width, block.height);
Â  Â  });
Â  Â  // IMPORTANTE: Desactivar sombreado global
Â  Â  ctx.shadowBlur = 0;
Â  }

Â  function drawPortals() {
Â  Â  // Optimizado: usamos solo una vez save/restore por portal
Â  Â  portals.forEach(portal => {
Â  Â  Â  ctx.save();
Â  Â  Â  ctx.translate(portal.x + portal.width/2, portal.y + portal.height/2);
Â  Â  Â Â 
Â  Â  Â  if (portal.type === 'ufo') {
Â  Â  Â  Â  ctx.shadowColor = '#f80'; 
Â  Â  Â  Â  ctx.shadowBlur = 15; // Menor blur
Â  Â  Â  Â  ctx.fillStyle = '#ff9900';
Â  Â  Â  Â  ctx.beginPath(); ctx.arc(0, 0, 25, 0, Math.PI*2); ctx.fill();
Â  Â  Â  Â  ctx.shadowBlur = 0;
Â  Â  Â  Â  ctx.fillStyle = '#000'; ctx.font = '24px Arial'; ctx.textAlign = 'center';
Â  Â  Â  Â  ctx.fillText('ğŸ›¸', 0, 8);
Â  Â  Â  }
Â  Â  Â  ctx.restore();
Â  Â  });
Â  }


Â  // ... (Resto de funciones: checkCollisions, checkPortalEntry, checkBlockLanding, update, etc. sin cambios significativos)

Â  function checkCollisions() {
Â  Â  for(let obs of obstacles) {
Â  Â  Â  if(player.x < obs.x + obs.width &&Â 
Â  Â  Â  Â  Â player.x + player.size > obs.x &&
Â  Â  Â  Â  Â player.y < obs.y + obs.height &&Â 
Â  Â  Â  Â  Â player.y + player.size > obs.y) {
Â  Â  Â  Â  return true;
Â  Â  Â  }
Â  Â  }
Â  Â  return false;
Â  }

Â  function checkPortalEntry() {
Â  Â  for(let portal of portals) {
Â  Â  Â  if(player.x < portal.x + portal.width &&Â 
Â  Â  Â  Â  Â player.x + player.size > portal.x &&
Â  Â  Â  Â  Â player.y < portal.y + portal.height &&Â 
Â  Â  Â  Â  Â player.y + player.size > portal.y) {
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (portal.type === 'ufo' && player.mode !== 'ufo') {
Â  Â  Â  Â  Â  player.mode = 'ufo';
Â  Â  Â  Â  Â  player.gravity = UFO_GRAVITY;
Â  Â  Â  Â  Â  player.jumpPower = UFO_BOUNCE;
Â  Â  Â  Â  Â  player.dy = 0;
Â  Â  Â  Â  Â  portals = portals.filter(p => p !== portal);
Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  }
Â  }

Â  function checkBlockLanding() {
Â  Â  let onBlock = false;
Â  Â  for(let block of blocks) {
Â  Â  Â  if(player.x + player.size > block.x &&Â 
Â  Â  Â  Â  Â player.x < block.x + block.width &&
Â  Â  Â  Â  Â player.y + player.size >= block.y &&Â 
Â  Â  Â  Â  Â player.y + player.size <= block.y + 15) {
Â  Â  Â  Â  player.y = block.y - player.size;
Â  Â  Â  Â  player.dy = 0;
Â  Â  Â  Â  player.grounded = true;
Â  Â  Â  Â  onBlock = true;
Â  Â  Â  Â  break;
Â  Â  Â  }
Â  Â  }
Â  Â  return onBlock;
Â  }

Â  function update() {
Â  Â  if(gameState !== 'playing') return;
    
    // Limpia y dibuja el fondo (esto es rÃ¡pido)
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
Â  Â  // Aplicar fÃ­sica
Â  Â  player.dy += player.gravity;
Â  Â  player.y += player.dy;
Â  Â Â 
Â  Â  const onBlock = checkBlockLanding();

Â  Â  if(!onBlock && player.y >= 150) {
Â  Â  Â  player.y = 150;
Â  Â  Â  player.dy = 0;
Â  Â  Â  player.grounded = true;
Â  Â  } else if (!onBlock && player.y < 150) {
Â  Â  Â  player.grounded = false;
Â  Â  }

Â  Â  if (player.y < 0) {
Â  Â  Â  player.y = 0;
Â  Â  Â  player.dy = 0;
Â  Â  }

Â  Â  const data = levelData[currentLevel];
Â  Â  // Mueve objetos
Â  Â  obstacles.forEach(obs => obs.x -= obs.speed);
Â  Â  blocks.forEach(b => b.x -= b.speed);
Â  Â  portals.forEach(p => p.x -= p.speed);
Â  Â  distanceTraveled += data.speed;
Â  Â  score += 0.5;

    // Dibuja lÃ­nea de suelo (rÃ¡pido)
Â  Â  ctx.shadowColor = '#fff'; ctx.shadowBlur = 5;
Â  Â  ctx.fillStyle = '#222';
Â  Â  ctx.fillRect(0, 175, canvas.width, 25);
Â  Â  ctx.shadowBlur = 0;
Â  Â Â 
Â  Â  // Filtra objetos (mantenimiento)
Â  Â  obstacles = obstacles.filter(obs => obs.x > -50);
Â  Â  blocks = blocks.filter(b => b.x > -100);
Â  Â  portals = portals.filter(p => p.x > -50);

Â  Â  // LLAMADAS CRÃTICAS (OPTIMIZADAS)
Â  Â  drawBlocks();
Â  Â  drawRealisticSpikes();
Â  Â  drawPortals();
Â  Â  drawAnimatedCube();

Â  Â  checkPortalEntry();
Â  Â  if(checkCollisions()) {
Â  Â  Â  endGame(false);
Â  Â  Â  return;
Â  Â  }

Â  Â  let progress = Math.min(distanceTraveled / levelLength * 100, 100);
Â  Â  progressBar.style.width = progress + '%';

Â  Â  if(distanceTraveled >= levelLength) {
Â  Â  Â  endGame(true);
Â  Â  Â  return;
Â  Â  }

Â  Â  // HUD
Â  Â  const levelColor = data.color;
Â  Â  ctx.shadowColor = levelColor; ctx.shadowBlur = 10; // Menor blur
Â  Â  ctx.fillStyle = '#fff';
Â  Â  ctx.font = 'bold 22px Arial';
Â  Â  ctx.fillText(`Nivel ${currentLevel} | Score: ${Math.floor(score)} | Modo: ${player.mode.toUpperCase()}`, 15, 35);
Â  Â  ctx.shadowBlur = 0;

Â  Â  requestAnimationFrame(update);
Â  }

Â  function jump() {
Â  Â  if(player.mode === 'cube' && player.grounded) {
Â  Â  Â  player.dy = player.jumpPower;
Â  Â  Â  player.grounded = false;
Â  Â  } else if (player.mode === 'ufo') {
Â  Â  Â  player.dy = player.jumpPower;
Â  Â  }
Â  }

Â  window.addEventListener('keydown', (e) => {
Â  Â  if((e.code === 'Space' || e.code === 'ArrowUp') && gameState === 'playing') {
Â  Â  Â  e.preventDefault();
Â  Â  Â  jump();
Â  Â  }
Â  });
Â  canvas.addEventListener('click', jump);

Â  document.getElementById('playBtn').onclick = () => showScreen('levels');
Â  document.querySelectorAll('.levelBtn').forEach(btn => {
Â  Â  btn.onclick = () => {Â 
Â  Â  Â  initLevel(parseInt(btn.dataset.level));Â 
Â  Â  Â  startGame();Â 
Â  Â  };
Â  });
Â  document.getElementById('backBtn').onclick = () => showScreen('start');
Â  document.getElementById('restartBtn').onclick = () => showScreen('levels');

Â  function endGame(completed) {
Â  Â  showScreen('over');
Â  Â  if (completed) {
Â  Â  Â  document.getElementById('gameOverText').textContent = `ğŸ‰ Â¡Nivel ${currentLevel} COMPLETADO! Score Final: ${Math.floor(score)}`;
Â  Â  } else {
Â  Â  Â  document.getElementById('gameOverText').textContent = `ğŸ’¥ Chocado! Nivel ${currentLevel} Score: ${Math.floor(score)}`;
Â  Â  }
Â  Â  gameState = 'over';
Â  }
Â  function startGame() {
Â  Â  showScreen('playing');
Â  Â  gameState = 'playing';
Â  Â  requestAnimationFrame(update);
Â  }
Â  showScreen('start'); 
</script>
</body>
</html>
