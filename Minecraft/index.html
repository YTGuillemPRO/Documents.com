<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Clone - Voxel Engine</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-weight: bold;
        }
        
        #instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px 25px;
            border-radius: 10px;
            text-align: center;
            font-size: 14px;
        }
        
        #instructions div {
            margin: 5px 0;
        }
        
        #block-selector {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }
        
        .block-option {
            width: 60px;
            height: 60px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 11px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            transition: all 0.2s;
            border: 2px solid rgba(255,255,255,0.3);
        }
        
        .block-option:hover {
            transform: scale(1.05);
        }
        
        .block-option.selected {
            border: 4px solid white;
            transform: scale(1.1);
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            background: rgba(0,0,0,0.8);
            padding: 20px 40px;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="ui-overlay">
        <div id="crosshair">+</div>
        
        <div id="instructions">
            <div>üñ±Ô∏è Click para bloquear cursor y empezar</div>
            <div>WASD: Mover | ESPACIO: Saltar | ESC: Liberar cursor</div>
            <div>Click Izq: Minar | Click Der: Colocar</div>
        </div>
        
        <div id="block-selector">
            <div class="block-option selected" data-type="grass" style="background-color: #5caa3a;">Grass</div>
            <div class="block-option" data-type="dirt" style="background-color: #8b6f47;">Dirt</div>
            <div class="block-option" data-type="stone" style="background-color: #808080;">Stone</div>
            <div class="block-option" data-type="wood" style="background-color: #9b6e3e;">Wood</div>
            <div class="block-option" data-type="sand" style="background-color: #edc9af;">Sand</div>
        </div>
    </div>
    
    <div id="loading">Cargando Minecraft Clone...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ============================================
        // CONFIGURACI√ìN
        // ============================================
        const BLOCK_TYPES = {
            grass: { color: 0x5caa3a },
            dirt: { color: 0x8b6f47 },
            stone: { color: 0x808080 },
            wood: { color: 0x9b6e3e },
            sand: { color: 0xedc9af }
        };
        
        const GRAVITY = -20;
        const PLAYER_HEIGHT = 1.7;
        const PLAYER_SPEED = 5;
        const JUMP_FORCE = 8;
        
        // ============================================
        // VARIABLES GLOBALES
        // ============================================
        let scene, camera, renderer, raycaster, mouse;
        let blocks = [];
        let selectedBlock = 'grass';
        let isLocked = false;
        
        // F√≠sica del jugador
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let moveState = { forward: false, backward: false, left: false, right: false, jump: false };
        let canJump = true;
        
        // ============================================
        // INICIALIZACI√ìN
        // ============================================
        function init() {
            // Escena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 50, 200);
            
            // C√°mara
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, PLAYER_HEIGHT + 10, 10);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Luces
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Raycaster para detecci√≥n
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2(0, 0);
            
            // Generar terreno inicial
            generateTerrain();
            
            // Event listeners
            setupEventListeners();
            
            // Ocultar loading
            document.getElementById('loading').style.display = 'none';
            
            // Iniciar animaci√≥n
            animate();
        }
        
        // ============================================
        // GENERAR TERRENO
        // ============================================
        function generateTerrain() {
            for (let x = -10; x <= 10; x++) {
                for (let z = -10; z <= 10; z++) {
                    const height = Math.floor(Math.random() * 3);
                    
                    for (let y = 0; y <= height; y++) {
                        const type = y === height ? 'grass' : y === height - 1 ? 'dirt' : 'stone';
                        addBlock(x, y, z, type);
                    }
                }
            }
            
            // A√±adir algunos √°rboles
            for (let i = 0; i < 10; i++) {
                const x = Math.floor(Math.random() * 20) - 10;
                const z = Math.floor(Math.random() * 20) - 10;
                
                for (let y = 1; y <= 5; y++) {
                    addBlock(x, y, z, 'wood');
                }
            }
        }
        
        // ============================================
        // A√ëADIR BLOQUE
        // ============================================
        function addBlock(x, y, z, type) {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshStandardMaterial({ 
                color: BLOCK_TYPES[type].color 
            });
            
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(x, y, z);
            cube.castShadow = true;
            cube.receiveShadow = true;
            cube.userData = { type, isBlock: true };
            
            // A√±adir edges
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 }));
            cube.add(line);
            
            scene.add(cube);
            blocks.push(cube);
        }
        
        // ============================================
        // ELIMINAR BLOQUE
        // ============================================
        function removeBlock(block) {
            scene.remove(block);
            blocks = blocks.filter(b => b !== block);
        }
        
        // ============================================
        // EVENT LISTENERS
        // ============================================
        function setupEventListeners() {
            // Pointer Lock
            renderer.domElement.addEventListener('click', () => {
                if (!isLocked) {
                    renderer.domElement.requestPointerLock();
                }
            });
            
            document.addEventListener('pointerlockchange', () => {
                isLocked = document.pointerLockElement === renderer.domElement;
            });
            
            // Mouse movement
            document.addEventListener('mousemove', onMouseMove);
            
            // Mouse clicks
            renderer.domElement.addEventListener('mousedown', onMouseClick);
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // Keyboard
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // Block selector
            document.querySelectorAll('.block-option').forEach(option => {
                option.addEventListener('click', (e) => {
                    document.querySelectorAll('.block-option').forEach(o => o.classList.remove('selected'));
                    e.target.classList.add('selected');
                    selectedBlock = e.target.dataset.type;
                });
            });
            
            // Resize
            window.addEventListener('resize', onWindowResize);
        }
        
        let euler = new THREE.Euler(0, 0, 0, 'YXZ');
        
        function onMouseMove(event) {
            if (!isLocked) return;
            
            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;
            
            euler.setFromQuaternion(camera.quaternion);
            euler.y -= movementX * 0.002;
            euler.x -= movementY * 0.002;
            euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
            camera.quaternion.setFromEuler(euler);
        }
        
        function onMouseClick(event) {
            if (!isLocked) return;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(blocks);
            
            if (intersects.length > 0) {
                const intersect = intersects[0];
                
                if (event.button === 0) {
                    // Click izquierdo - Minar
                    removeBlock(intersect.object);
                } else if (event.button === 2) {
                    // Click derecho - Colocar
                    const normal = intersect.face.normal;
                    const newPos = intersect.point.clone().add(normal.multiplyScalar(0.5));
                    
                    const x = Math.round(newPos.x);
                    const y = Math.round(newPos.y);
                    const z = Math.round(newPos.z);
                    
                    addBlock(x, y, z, selectedBlock);
                }
            }
        }
        
        function onKeyDown(event) {
            switch(event.code) {
                case 'KeyW': moveState.forward = true; break;
                case 'KeyS': moveState.backward = true; break;
                case 'KeyA': moveState.left = true; break;
                case 'KeyD': moveState.right = true; break;
                case 'Space': 
                    if (canJump) moveState.jump = true;
                    break;
            }
        }
        
        function onKeyUp(event) {
            switch(event.code) {
                case 'KeyW': moveState.forward = false; break;
                case 'KeyS': moveState.backward = false; break;
                case 'KeyA': moveState.left = false; break;
                case 'KeyD': moveState.right = false; break;
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // ============================================
        // F√çSICA Y MOVIMIENTO
        // ============================================
        function updatePlayer(delta) {
            if (!isLocked) return;
            
            direction.set(0, 0, 0);
            
            if (moveState.forward) direction.z -= 1;
            if (moveState.backward) direction.z += 1;
            if (moveState.left) direction.x -= 1;
            if (moveState.right) direction.x += 1;
            
            direction.normalize();
            
            // Direcci√≥n de la c√°mara
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();
            
            const right = new THREE.Vector3();
            right.crossVectors(forward, camera.up).normalize();
            
            velocity.x = (forward.x * direction.z + right.x * direction.x) * PLAYER_SPEED;
            velocity.z = (forward.z * direction.z + right.z * direction.x) * PLAYER_SPEED;
            
            // Gravedad
            velocity.y += GRAVITY * delta;
            
            // Salto
            if (moveState.jump && canJump) {
                velocity.y = JUMP_FORCE;
                canJump = false;
                moveState.jump = false;
            }
            
            // Actualizar posici√≥n
            camera.position.x += velocity.x * delta;
            camera.position.y += velocity.y * delta;
            camera.position.z += velocity.z * delta;
            
            // Colisi√≥n con el suelo
            if (camera.position.y <= PLAYER_HEIGHT) {
                camera.position.y = PLAYER_HEIGHT;
                velocity.y = 0;
                canJump = true;
            }
            
            // Colisiones con bloques
            blocks.forEach(block => {
                const blockBox = new THREE.Box3().setFromObject(block);
                const playerBox = new THREE.Box3(
                    new THREE.Vector3(camera.position.x - 0.3, camera.position.y - PLAYER_HEIGHT, camera.position.z - 0.3),
                    new THREE.Vector3(camera.position.x + 0.3, camera.position.y, camera.position.z + 0.3)
                );
                
                if (blockBox.intersectsBox(playerBox)) {
                    camera.position.y = block.position.y + 0.5 + PLAYER_HEIGHT;
                    velocity.y = 0;
                    canJump = true;
                }
            });
        }
        
        // ============================================
        // LOOP DE ANIMACI√ìN
        // ============================================
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            updatePlayer(delta);
            
            renderer.render(scene, camera);
        }
        
        // ============================================
        // INICIAR
        // ============================================
        init();
    </script>
</body>
</html>
